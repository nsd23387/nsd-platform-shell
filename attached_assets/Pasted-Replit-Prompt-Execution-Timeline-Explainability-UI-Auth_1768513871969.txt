Replit Prompt â€” Execution Timeline & Explainability UI (Authoritative)

Project Context
You are working inside the NSD Sales Engine UI.
This is a UI-only, read-only enhancement to improve execution observability and user explainability.

ğŸ”’ Hard Constraints (Non-Negotiable)

âŒ NO backend changes

âŒ NO schema changes

âŒ NO cron / worker / execution logic changes

âŒ NO Apollo logic

âŒ NO Supabase mutations

âŒ NO new API endpoints

âŒ NO inference beyond explicit signals

âœ… READ-ONLY UI only

âœ… Consume existing APIs and data exactly as-is

This task is about explaining execution, not changing it.

ğŸ“¦ Target Repository (IMPORTANT)

Repo: nsd-platform-shell
This work must live entirely in the Platform Shell UI, not in:

nsd-sales-engine (backend execution)

nsd-ods-api (data / semantics)

The Platform Shell already consumes Sales Engine APIs â€” extend that consumption only.

ğŸ¯ Goal

Replace ambiguous execution indicators like:

â€œRunningâ€

â€œQueue modeâ€

â€œAwaiting executionâ€

with a clear, user-explainable Execution Timeline that answers:

Did my campaign actually run?

Was anything queued?

Did the worker do work or intentionally do nothing?

Is this idle, completed, or waiting â€” and why?

A non-technical user must understand execution state without reading logs.

ğŸ”Œ Data Sources (Consume Only)

You may consume only existing sources, including:

Sales Engine API

GET /api/v1/campaigns/:id/runs/latest

Legacy fallback already exists in useLatestRunStatus

Existing run fields

campaign_runs.status

campaign_runs.execution_mode

campaign_runs.created_at

campaign_runs.updated_at

Existing observability signals

Presence or absence of runs

queued vs non-queued states

Known â€œno workâ€ outcomes (e.g. cron idle semantics)

âš ï¸ If a signal is not explicitly available, do not invent it.

ğŸ§  What You Must Build
1. Execution Timeline Component (New UI)

Create a read-only component that renders a deterministic timeline, for example:

Execution Timeline
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ Run created (Jan 15, 21:32)
âš ï¸ No queued work detected
â„¹ï¸ Worker checked queue and found no executable steps


OR (when applicable):

âœ“ Run created
âœ“ Run queued
âœ“ Worker started execution
â³ Executing: Organization Sourcing


This component must:

Be derived entirely from existing data

Never imply backend failure

Explicitly explain â€œnothing happenedâ€ as a valid state

2. Explicit Status Explanations (Critical)

Replace ambiguous labels with explanatory copy.

Examples (choose exact copy or improve it):

No queued runs

â€œThis campaign was approved, but no executable steps were eligible at this time.â€

Queue mode + idle

â€œThe execution worker checked the queue and found no work. This may occur if execution completed immediately or no sourcing criteria produced results.â€

Run exists, no phases

â€œExecution completed without entering the queue. No external services were contacted.â€

3. Strict State Mapping (No Inference)

Create a small adapter that maps raw backend signals â†’ user-meaningful states.

Example mapping table (must be explicit in code comments):

Backend Condition	UI Meaning
No run exists	â€œCampaign not executed yetâ€
Run exists + status=queued	â€œAwaiting worker pickupâ€
Run exists + cron idle	â€œNo eligible work foundâ€
Run exists + completed	â€œExecution finishedâ€

Do not infer Apollo usage or execution phases unless explicitly observable.

ğŸ§© Where to Integrate

Integrate the timeline directly into the Campaign detail page

Place it near:

â€œLatest Run Statusâ€

â€œExecution Statusâ€

This component replaces ambiguity, not adds noise

ğŸ§ª Validation Checklist (Must Pass)

âœ… UI correctly explains the current â€œstuck in queueâ€ scenario

âœ… UI makes it clear Apollo was not reached

âœ… No backend code was touched

âœ… No new API calls were added

âœ… A non-technical user can understand execution outcome

âœ… Execution â€œdoing nothingâ€ is clearly presented as intentional

ğŸš« Explicit Non-Goals

Do not fix execution semantics

Do not add retries

Do not change queue behavior

Do not force runs into queued

Do not simulate backend states

Do not add debug-only UI

ğŸ“Œ Success Criteria

This work is complete when:

A user can look at the campaign page and immediately understand
what happened, why it happened, and whether action is required â€” without logs.

If Replit asks clarifying questions, default to:

Read-only

Explain, donâ€™t infer

UI clarity over technical detail